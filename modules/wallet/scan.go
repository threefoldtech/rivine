package wallet

import (
	"fmt"

	"github.com/rivine/rivine/build"
	"github.com/rivine/rivine/modules"
	"github.com/rivine/rivine/persist"
	"github.com/rivine/rivine/types"
)

const scanMultiplier = 4 // how many more keys to generate after each scan iteration

var errMaxKeys = fmt.Errorf("refused to generate more than %v keys from seed", maxScanKeys)

// maxScanKeys is the number of maximum number of keys the seedScanner will
// generate before giving up.
var maxScanKeys = func() uint64 {
	switch build.Release {
	case "dev":
		return 1e6
	case "standard":
		return 100e6
	case "testing":
		return 100e3
	default:
		panic("unrecognized build.Release")
	}
}()

// numInitialKeys is the number of keys generated by the seedScanner before
// scanning the blockchain for the first time.
var numInitialKeys = func() uint64 {
	switch build.Release {
	case "dev":
		return 10e3
	case "standard":
		return 1e6
	case "testing":
		return 1e3
	default:
		panic("unrecognized build.Release")
	}
}()

// A scannedOutput is an output found in the blockchain that was generated
// from a given seed.
type scannedOutput struct {
	id        types.OutputID
	value     types.Currency
	condition types.UnlockConditionProxy
	seedIndex uint64
}

// A seedScanner scans the blockchain for addresses that belong to a given
// seed.
type seedScanner struct {
	keys                      map[types.UnlockHash]uint64 // map address to seed index
	largestIndexSeen          uint64                      // largest index that has appeared in the blockchain
	seed                      modules.Seed
	coinOutputs               map[types.CoinOutputID]scannedOutput
	blockStakeOutputs         map[types.BlockStakeOutputID]scannedOutput
	multiSigCoinOutputs       map[types.CoinOutputID]scannedOutput
	multiSigBlockStakeOutputs map[types.BlockStakeOutputID]scannedOutput

	log *persist.Logger
}

func (s *seedScanner) numKeys() uint64 {
	return uint64(len(s.keys))
}

// generateKeys generates n additional keys from the seedScanner's seed.
func (s *seedScanner) generateKeys(n uint64) {
	initialProgress := s.numKeys()
	for i, k := range generateKeys(s.seed, initialProgress, n) {
		s.keys[k.UnlockHash()] = initialProgress + uint64(i)
	}
}

// ProcessConsensusChange scans the blockchain for information relevant to the
// seedScanner.
func (s *seedScanner) ProcessConsensusChange(cc modules.ConsensusChange) {
	// update outputs & largest seen index
	for _, diff := range cc.CoinOutputDiffs {
		if diff.CoinOutput.Condition.Condition == nil {
			continue // no need to continue, we ignore nil condition outputs for this purpose
		}
		var (
			exists bool
			index  uint64
			m      map[types.CoinOutputID]scannedOutput
		)
		if index, exists = s.keys[diff.CoinOutput.Condition.UnlockHash()]; !exists {
			// try to add it as multisig if our address appears in it
			uhs, _ := getMultisigConditionProperties(diff.CoinOutput.Condition.Condition)
			for _, uh := range uhs {
				if index, exists = s.keys[uh]; exists {
					m = s.multiSigCoinOutputs
					break
				}
			}
			if !exists {
				continue
			}
		} else {
			// found index, referenced by a PubKey (SingleSig) unlock hash
			m = s.coinOutputs
		}

		// update s.LargestIndexSeen
		s.log.Debugln("Seed scanner found a key used at index", index)
		if index > s.largestIndexSeen {
			s.largestIndexSeen = index
		}

		// update coin output
		if diff.Direction == modules.DiffApply {
			// NOTE: this does not mean the output is also fulfillable,
			// it only means that at this point of the consensus state it is spendable and owned by the embedded seed
			m[diff.ID] = scannedOutput{
				id:        types.OutputID(diff.ID),
				value:     diff.CoinOutput.Value,
				condition: diff.CoinOutput.Condition,
				seedIndex: index,
			}
		} else if diff.Direction == modules.DiffRevert {
			delete(m, diff.ID)
		}
	}
	for _, diff := range cc.BlockStakeOutputDiffs {
		if diff.BlockStakeOutput.Condition.Condition == nil {
			continue // no need to continue, we ignore nil condition outputs for this purpose
		}
		var (
			exists bool
			index  uint64
			m      map[types.BlockStakeOutputID]scannedOutput
		)
		if index, exists = s.keys[diff.BlockStakeOutput.Condition.UnlockHash()]; !exists {
			// try to add it as multisig if our address appears in it
			uhs, _ := getMultisigConditionProperties(diff.BlockStakeOutput.Condition.Condition)
			for _, uh := range uhs {
				if index, exists = s.keys[uh]; exists {
					m = s.multiSigBlockStakeOutputs
					break
				}
			}
			if !exists {
				continue
			}
		} else {
			m = s.blockStakeOutputs
			// found index, referenced by a PubKey (SingleSig) unlock hash
		}

		// update s.LargestIndexSeen
		s.log.Debugln("Seed scanner found a key used at index", index)
		if index > s.largestIndexSeen {
			s.largestIndexSeen = index
		}

		// update block stake output
		if diff.Direction == modules.DiffApply {
			// NOTE: this does not mean the output is also fulfillable,
			// it only means that at this point of the consensus state it is spendable and owned by the embedded seed
			m[diff.ID] = scannedOutput{
				id:        types.OutputID(diff.ID),
				value:     diff.BlockStakeOutput.Value,
				condition: diff.BlockStakeOutput.Condition,
				seedIndex: index,
			}
		} else if diff.Direction == modules.DiffRevert {
			delete(m, diff.ID)
		}
	}
}

// scan subscribes s to cs and scans the blockchain for addresses that belong
// to s's seed. If scan returns errMaxKeys, additional keys may need to be
// generated to find all the addresses.
func (s *seedScanner) scan(cs modules.ConsensusSet, cancel <-chan struct{}) error {
	// generate a bunch of keys and scan the blockchain looking for them. If
	// none of the 'upper' half of the generated keys are found, we are done;
	// otherwise, generate more keys and try again (bounded by a sane
	// default).
	//
	// NOTE: since scanning is very slow, we aim to only scan once, which
	// means generating many keys.
	var numKeys = numInitialKeys
	for s.numKeys() < maxScanKeys {
		s.generateKeys(numKeys)
		if err := cs.ConsensusSetSubscribe(s, modules.ConsensusChangeBeginning, cancel); err != nil {
			return err
		}
		cs.Unsubscribe(s)
		if s.largestIndexSeen < s.numKeys()/2 {
			return nil
		}
		// increase number of keys generated each iteration, capping so that
		// we do not exceed maxScanKeys
		numKeys *= scanMultiplier
		if numKeys > maxScanKeys-s.numKeys() {
			numKeys = maxScanKeys - s.numKeys()
		}
	}
	return errMaxKeys
}

// newSeedScanner returns a new seedScanner.
func newSeedScanner(seed modules.Seed, log *persist.Logger) *seedScanner {
	return &seedScanner{
		seed:                      seed,
		keys:                      make(map[types.UnlockHash]uint64, numInitialKeys),
		coinOutputs:               make(map[types.CoinOutputID]scannedOutput),
		blockStakeOutputs:         make(map[types.BlockStakeOutputID]scannedOutput),
		multiSigCoinOutputs:       make(map[types.CoinOutputID]scannedOutput),
		multiSigBlockStakeOutputs: make(map[types.BlockStakeOutputID]scannedOutput),

		log: log,
	}
}
